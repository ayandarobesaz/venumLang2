program     -> decleration* EOF;

decleration -> varDecl | statement
            | funDeclr;

varDecl     -> type IDENTIFIER ("=" expression)? ";"

statement   -> exprStmt
            | printStmt
            | block
            | ifStmt
            | whileStmt
            | forStmt
            | continueStmt
            | breakStmt

funDeclr    -> "func" function;
function    -> TYPES IDENTIFIER "(" params? ")" block;
params      -> TYPES IDENTIFIER ("," TYPES IDENTIFIER)*;


forStmt     -> "for" "(" (varDecl | exprStmt | ";")
                expression? ";"
                expression? ")" statement

            

whileStmt   -> "while" "(" expression ")" statement

ifStmt      -> "if" "(" expression ")"
                statement
                ("elif" "(" expression ")" statement)*
                ("else" statement)?

continueStmt -> "continue" ";"
breakStmt    -> "break" ";"

block       -> "{" decleration* "}"

exprStmt    -> expression ";";
printStmt   -> "print" expression ";";

expression  -> assigment;
assigment   -> IDENTIFIER ("=" | "+=" | "*=" | "/=") expression 
            | equality;
equality    -> comparison ( ( "!=" | "==" ) comparison )*
comparison  -> term ( ( ">" | ">=" | "<" | "<=" ) term )*
term        -> factor ( ( "+" | "-") factor )*
factor      -> unary ( ( "*" | "/"  ) unary )*
unary       -> ( "!" | "-" ) unary | call

call        -> primary ( "(" arguments? ")" )
arguments   -> expression ( "," expression )*
                                                                                 reference shuld be unary
primary     -> NUMBER | STRING | "true" | "false" | "null" | "(" expression ")" | "&"? IDENTIFIER | "*" expression
type        -> "BYTE" | "SHORT" | "INT" | "LONG"




Grammar notation	Code representation

Terminal	        Code to match and consume a token
Nonterminal     	Call to that ruleâ€™s function
|	                if or switch statement
* or +	            while or for loop
?	                if statement